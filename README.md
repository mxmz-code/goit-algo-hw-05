# Домашнє завдання до теми “Алгоритми пошуку” (goit-algo-hw-05)

Цей репозиторій містить реалізацію трьох завдань з порівняння ефективності алгоритмів пошуку підрядка та деякі інші задачі.

## Завдання 1: Алгоритм для видалення пари ключ-значення в таблиці HashTable

Це завдання полягає у реалізації методу **`delete`** для видалення пари ключ-значення в таблиці HashTable. Це важлива частина будь-якої структури даних, яка використовує хешування для зберігання значень.

### Як використовувати:
1. Використовувати метод **`delete`** для видалення пари:
   ```python
   hash_table.delete(key)
   ```
2. Після видалення, таблиця автоматично оновлюється, і можна перевірити результат через методи **`get`** або **`keys`**.

---

## Завдання 2: Двійковий пошук для відсортованого масиву

Це завдання передбачає реалізацію **двійкового пошуку** для відсортованого масиву з дробовими числами. Функція **`binary_search()`** повертає кортеж, де першим елементом є кількість ітерацій, а другим — найменший елемент, який є більшим або рівним заданому значенню.

### Як використовувати:
1. Викликайте функцію **`binary_search()`** з масивом і шуканим значенням:
   ```python
   iterations, result = binary_search(sorted_array, target)
   ```
2. Якщо елемент знайдений, повертається його позиція, якщо ні — верхня межа (найменший елемент, який більший або рівний заданому).

---

## Завдання 3: Порівняння ефективності алгоритмів пошуку підрядка

Це завдання передбачає порівняння ефективності трьох алгоритмів пошуку підрядка:
- **Алгоритм Бойєра-Мура**
- **Алгоритм Кнута-Морріса-Пратта (KMP)**
- **Алгоритм Рабіна-Карпа (Rabin-Karp)**

Для кожного алгоритму вимірюється час виконання для двох видів підрядків:
1. Підрядок, що існує в тексті.
2. Підрядок, якого немає в тексті.

### Як використовувати:
1. Вибирається випадковий текстовий файл з директорії **`txt/`**.
2. Для кожного тексту виконуються три алгоритми пошуку.
3. Час виконання кожного алгоритму виводиться в консоль, а також будуються графіки порівняння.
4. Результати порівняння зберігаються в файл **`results_comparison.md`** в директорії **`logs/`** у форматі Markdown.

### Приклад результату в консоль:
```bash
Запуск Завдання 3: Порівняння ефективності алгоритмів пошуку підрядка.
Кодування файлу example.txt: UTF-8
Існуючий підрядок для пошуку: алгоритм
Неіснуючий підрядок для пошуку: ZZZZZZZZZZZZZZZZ

Тестування для існуючого підрядка:
Boyer-Moore: Знайдено на позиції 10, час: 0.000250 секунд
KMP: Знайдено на позиції 10, час: 0.000350 секунд
Rabin-Karp: Знайдено на позиції 10, час: 0.000300 секунд

Тестування для вигаданого підрядка:
Boyer-Moore: Знайдено на позиції -1, час: 0.000200 секунд
KMP: Знайдено на позиції -1, час: 0.000250 секунд
Rabin-Karp: Знайдено на позиції -1, час: 0.000230 секунд

Найшвидший алгоритм: Boyer-Moore з часом 0.000200 секунд
Найповільніший алгоритм: KMP з часом 0.000350 секунд
Процентна різниця між найшвидшим та найповільнішим алгоритмом: 75.00%

Висновки збережено у файл results_comparison.md в папці logs.
```

## Формат результатів у файлі `results_comparison.md`

### Висновки щодо порівняння алгоритмів пошуку підрядка

#### Найшвидший алгоритм
Найшвидший алгоритм: **Boyer-Moore** з часом **0.000200 секунд**.

#### Найповільніший алгоритм
Найповільніший алгоритм: **KMP** з часом **0.000350 секунд**.

#### Процентна різниця
Процентна різниця між найшвидшим та найповільнішим алгоритмом: **75.00%**.

#### Детальні результати для існуючого підрядка:
- **Boyer-Moore**: Час: **0.000250 секунд**, Позиція підрядка: **10**
- **KMP**: Час: **0.000350 секунд**, Позиція підрядка: **10**
- **Rabin-Karp**: Час: **0.000300 секунд**, Позиція підрядка: **10**

#### Детальні результати для вигаданого підрядка:
- **Boyer-Moore**: Час: **0.000200 секунд**, Позиція підрядка: **-1**
- **KMP**: Час: **0.000250 секунд**, Позиція підрядка: **-1**
- **Rabin-Karp**: Час: **0.000230 секунд**, Позиція підрядка: **-1**

## Примітки
- Для кожного текстового файлу вибирається випадковий підрядок, який існує в тексті, і вигаданий підрядок.
- Всі вимірювання часу виконуються з використанням вбудованої функції `time.time()` для точності.
